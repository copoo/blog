SED单行脚本快速参考（Unix 流编辑器）
http://sed.sourceforge.net/sed1line_zh-CN.html
http://witmax.cn/linux-sed-usage.html
http://coolshell.cn/articles/9104.html


sed从文件的一个文本行或从标准输入的几种格式中读取数据，将之拷贝到一个编辑缓冲区，然后读命令行或脚本的第一条命令，
并使用这些命令查找模式或定位行号编辑它。重复此过程直到命令结束。

定位
编辑
	sed -i '/echo \"2\";/a\echo \"3\";' test.sh		在匹配行后增加
	sed '/test/i\\new line――――――――-' example 		如果test被匹配，则把反斜杠后面的文本插入到匹配行的前面。
	sed ‘/test/{ n; s/aa/bb/; }’ example		如果test被匹配，则移动到匹配行的下一行，替换这一行的aa，变为bb，并打印该行，然后继续。
sed [options] ‘command’ file(s)
sed [options] -f scriptfile file(s)

----------------------------------------------------------------------------------------------------
参数
-e	允许多个编辑
-h
-i	编辑原文
-n	不打印
-f	可以指定sed脚本文件。Sed脚本是一个sed的命令清单，启动Sed时以-f选项引导脚本文件名。
	Sed对于脚本中输入的命令非常挑剔，在命令的末尾不能有任何空白或文本，如果在一行中有多个命令，要用分号分隔。
	以#开头的行为注释行，且不能跨行。
-V
-r	可以使用扩展的正则表达式
----------------------------------------------------------------------------------------------------
命令
a\	在当前行后面加入一行文本,注意a后必须有反斜杠
b	进入标签分支，如果没有，到脚本的结尾
c\	用新的文本改变本行的文本
d	从模板块位置删除行
D	删除模板块的第一行	?
i\	在当前行上面插入文本
h	拷贝模板块的内容到内存中的缓冲区。
H	追加模板块的内容到内存中的缓冲区
g	获得内存缓冲区的内容，并替代当前模板块中的文本。
G	获得内存缓冲区的内容，并追加到当前模板块文本的后面。
l	显示与八进制A S C I I代码等价的控制字符		?
n	读取下一个输入行，用下一个命令处理新的行而不是用第一个命令。	?
N	追加下一个输入行到模板块后面并在二者间嵌入一个新行，改变当前行号码。	（两行合一行，但是有\n）
p	打印模板块的行
P	打印模板块的第一行
q	退出Sed
r file	从file中读行	?
t label	if分支，从最后一行开始，条件一旦满足或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾。?
T label	错误分支，从最后一行开始，一旦发生错误或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾。?
w file	写并追加模板块到file末尾。?
W file	写并追加模板块的第一行到file末尾。?
!	表示后面的命令对所有没有被选定的行发生作用。sed '/baz/!s/foo/bar/g'
s/re/string/	用string替换正则表达式re
	替换标记:
	g	行内全面替换。
	p	打印行。
	w	把行写入一个文件。
	x	互换模板块中的文本和缓冲区中的文本。
y	把一个字符翻译为另外的字符（但是不用于正则表达式）	
=	打印当前行号码。此行号单独占一行
#	把注释扩展到下一个换行符以前。?
{}	命令组

----------------------------------------------------------------------------------------------------
定址
数字	1，3表示1，2，3行，美元符号($)表示最后一行
正则	/pattern/pattern/ #查询包含两个模式的行。例如/disk/disks/
混合	/pattern/,x #在给定行号上查询包含模式的行。如/ribbon/,3
		x,y! #查询不包含指定行号x和y的行。1,2!

----------------------------------------------------------------------------------------------------
元字符集
^	锚定行的开始 如：/^sed/匹配所有以sed开头的行。
$	锚定行的结束 如：/sed$/匹配所有以sed结尾的行。
.	匹配一个非换行符的字符 如：/s.d/匹配s后接一个任意字符，然后是d。
*	匹配零或多个字符 如：/*sed/匹配所有模板是一个或多个空格后紧跟sed的行。
?	
+
[]	匹配一个指定范围内的字符，如/[Ss]ed/匹配sed和Sed。
[^]	匹配一个不在指定范围内的字符，如：/[^A-RT-Z]ed/匹配不包含A-R和T-Z的一个字母开头，紧跟ed的行。
\(..\)	保存匹配的字符，如s/\(love\)able/\1rs，loveable被替换成lovers。
&	保存搜索字符用来替换其他字符，如s/love/**&**/，love这成**love**。
\<	锚定单词的开始，如:/\<love/匹配包含以love开头的单词的行。
\>	锚定单词的结束，如/love\>/匹配包含以love结尾的单词的行。
x\{m\}	重复字符x，m次，如：/0\{5\}/匹配包含5个o的行。
x\{m,\}	重复字符x,至少m次，如：/o\{5,\}/匹配至少有5个o的行。
x\{m,n\}	重复字符x，至少m次，不多于n次，如：/o\{5,10\}/匹配5C10个o的行。

----------------------------------------------------------------------------------------------------
实例
sed ’2,$d’ example	删除example文件的第二行到末尾所有行
sed ‘/test/’d example	删除example文件所有包含test的行

sed -n ‘s/^test/mytest/p’ example			(-n)选项和p标志一起使用表示只打印那些发生替换的行。
sed ‘s/^192.168.0.1/&localhost/’ example	&符号表示替换换字符串中被找到的部份。
sed -n ‘s/\(love\)able/\1rs/p’ example		所有loveable会被替换成lovers，而且替换的行会被打印出来
sed ‘s#10#100#g’ example					不论什么字符，紧跟着s命令的都被认为是新的分隔符

sed -n ‘/test/,/check/p’ example	所有在模板test和check所确定的范围内的行都被打印。
sed -n ’5,/^test/p’ example			打印从第五行开始到第一个包含以test开始的行之间的所有行。
sed ‘/test/,/check/s/$/sed test/’ example		对于模板test和west之间的行，每行的末尾用字符串sed test替换。

sed -e ’1,5d’ -e ‘s/test/check/’ example		(-e)选项允许在同一行里执行多条命令。
	如例子所示，第一条命令删除1至5行，第二条命令用check替换test。命令的执行顺序对结果有影响。
	如果两个命令都是替换命令，那么第一个替换命令将影响第二个替换命令的结果。	
sed Cexpression=’s/test/check/’ Cexpression=’/love/d’ example	一个比-e更好的命令是Cexpression。它能给sed表达式赋值。
sed "s/tiger/wolf/; s/after/before/" example	使用;也可以多编辑

sed ‘/test/r file’ example	file里的内容被读进来，显示在与test匹配的行后面，如果匹配多行，则file的内容将显示在所有匹配行的下面。

sed -n ‘/test/w file’ example	在example中所有包含test的行都被写入file里。

sed ‘/^test/a\\―>this is a example’ example		’this is a example’被追加到以test开头的行后面，sed要求命令a后面有一个反斜杠。

sed ‘/test/i\\new line――――――――-’ example		如果test被匹配，则把反斜杠后面的文本插入到匹配行的前面。

sed 'c\this line will be modified to the each line!oooooooooo' test.txt		替换每一行

sed ‘/test/{ n; s/aa/bb/; }’ example		如果test被匹配，则移动到匹配行的下一行，替换这一行的aa，变为bb，并打印该行，然后继续。

sed ’1,10y/abcde/ABCDE/’ example	把1C10行内所有abcde转变为大写，注意，正则表达式元字符不能使用这个命令。

sed ’10q’ example	打印完第10行后，退出sed。

sed -e ‘/test/h’ -e '$G' example	在sed处理文件的时候，每一行都被保存在一个叫模式空间的临时缓冲区中，
	除非行被删除或者输出被取消，否则所有被处理的行都将打印在屏幕上。接着模式空间被清空，并存入新的一行等待处理。
	在这个例子里，匹配test的行被找到后，将存入模式空间，h命令将其复制并存入一个称为保持缓存区的特殊缓冲区内。
	第二条语句的意思是，当到达最后一行后，G命令取出保持缓冲区的行，然后把它放回模式空间中，且追加到现在已经存在于模式空间中的行的末尾。
	在这个例子中就是追加到最后一行。简单来说，任何包含test的行都被复制并追加到该文件的末尾。

sed -e ‘/test/h’ -e ‘/check/x’ example	互换模式空间和保持缓冲区的内容。也就是把包含test与check的行互换。
sed -n '1h;1!H;${g;s/\n/ /g;p;}' test.txt	把换行改为空格。把整个文件读入保持空间，处理最后一行的时候，替换所有换行符为空格，打印。
----------------------------------------------------------------------------------------------------
技巧
在sed的命令行中引用shell变量时要使用双引号，而不是通常所用的单引号。

sed -e :a -e 's/-\([0-9]\)\([- ]\)/-0\1\2/;ta' file.txt		:a C label，ta C goto to :a to rerun sed if the last sed is finished successfully.简单说， 就是循环。

脚本文件开头，可以给它赋执行权限
#!/bin/sed -f
----------------------------------------------------------------------------------------------------
单行脚本快速参考

文本间隔：
--------
sed G			在每一行后面增加一空行
sed 'G;G'		在每一行后面增加两行空行
sed '/^$/d;G'	每一行后面将有且只有一空行。
sed 'n;d'		即删除所有偶数行

sed '/regex/G'			在匹配式样“regex”的行之后插入一空行
sed '/regex/{x;p;x;}'	在匹配式样“regex”的行之前插入一空行（x,把缓存区和模式区对换，缓冲区是空，当p打印时，会生成空行，然后x再次对换，又换回原有内容，也就是原有行数据）
sed '/regex/{x;p;x;G;}'	在匹配式样“regex”的行之前和之后各插入一空行

编号：
--------
sed = filename | sed 'N;s/\n/\t/'	为文件中的每一行进行编号。N是把编号行和数据行都读入模式缓冲区，\n换成\t是为了把两行合并为一行
sed = filename | sed 'N; s/^/     /; s/ *\(.\{6,\}\)\n/\1  /'	对文件中的所有行编号（行号在左，右端对齐）。N读入下一行;给行号行扩充前缀空格;截取定长行号，并合并为一行。
sed '/./=' filename | sed '/./N; s/\n/ /'	只显示非空白行的行号。
sed -n '$='		计算行数 （模拟 "wc -l"）;只打印最后一行的行号

文本转换和替代：
--------
sed 's/.$//'					转换DOS的新行符（CR/LF）为Unix格式。假设所有行以CR/LF结束。删除最后一个字符
sed "s/$/`echo -e \\\r`/"		Unix环境：转换Unix的新行符（LF）为DOS格式。在ksh下所使用的命令
sed 's/^[ \t]*//;s/[ \t]*$//'	将每一行中的前导和拖尾的空白字符删除
sed -e :a -e 's/^.\{1,78\}$/ &/;ta'		以79个字符为宽度，将所有文本右对齐。78个字符外加最后的一个空格。如果行中字符串不够79个，就总是添加一个空格在左边，循环直到行字符串超过78个，不符合匹配模式为止。
sed	-e :a -e 's/^.\{1,77\}$/ & /;ta'	以79个字符为宽度，使所有文本居中。每一行的前头和后头都填充了空格。
sed	-e :a -e 's/^.\{1,77\}$/ &/;ta' -e 's/\( *\)\1/\1/'		只在文本的前面填充空格，最后将这些空格中的一半删除。
sed 's/\(.*\)foo\(.*foo\)/\1bar\2/'		替换倒数第二个“foo”
sed '/baz/s/foo/bar/g'			只在行中出现字串“baz”的情况下将“foo”替换成“bar”
sed '/baz/!s/foo/bar/g'			将“foo”替换成“bar”，并且只在行中未出现字串“baz”的情况下替换
sed 's/scarlet/red/g;s/ruby/red/g;s/puce/red/g'		不管是“scarlet”“ruby”还是“puce”，一律换成“red”
sed '1!G;h;$!d'			倒置所有行，第一行成为最后一行，依次类推（模拟“tac”）。追加内存缓冲区数据到当前行，把这些数据保存到内存缓冲区，把当前行存入缓存区；第一行不处理，非最后一行删除（不打印），最后一行时把内存缓冲区的内容打印处理（不删除）。
sed -n '1!G;h;$p'		倒置所有行，第一行成为最后一行，依次类推（模拟“tac”）。这个和上一个类似，就是逐条把当前行倒序加入内存缓冲区，最后一行时打印。
sed '/\n/!G;s/\(.\)\(.*\n\)/&\2\1/;//D;s/.//'	将行中的字符逆序排列，第一个字成为最后一字，……（模拟“rev”）	?
sed '$!N;s/\n/ /'		将每两行连接成一行（类似“paste”）
sed -e :a -e '/\\$/N; s/\\\n//; ta'		如果当前行以反斜杠“\”结束，则将下一行并到当前行末尾并去掉原来行尾的反斜杠	?
sed -e :a -e '$!N;s/\n=/ /;ta' -e 'P;D'	如果当前行以等号开头，将当前行并到上一行末尾并以单个空格代替原来行头的“=”	?
sed -e :a -e 's/\(.*[0-9]\)\([0-9]\{3\}\)/\1,\2/;ta'	为数字字串增加逗号分隔符号，将“1234567”改为“1,234,567”
sed 'n;n;n;n;G;'	在每5行后增加一空白行 （在第5，10，15，20，等行后增加一空白行）

选择性地显示特定行：
--------
sed 10q		显示文件中的前10行 （模拟“head”的行为）
sed q		显示文件中的第一行 （模拟“head -1”命令）
sed -e :a -e '$q;N;11,$D;ba'	显示文件中的最后10行 （模拟“tail”）	?
sed '$!N;$!D'	显示文件中的最后2行（模拟“tail -2”命令）	N会导致行号变化，会影响后一个$!D的判断	?
sed '$!d'		显示文件中的最后一行（模拟“tail -1”）
sed -n '$p'		显示文件中的最后一行（模拟“tail -1”）
sed -e '$!{h;d;}' -e x		显示文件中的倒数第二行#当文件中只有一行时，输入空行		?
sed -e '1{$q;}' -e '$!{h;d;}' -e x		显示文件中的倒数第二行#当文件中只有一行时，显示该行		?
sed -e '1{$d;}' -e '$!{h;d;}' -e x		显示文件中的倒数第二行#当文件中只有一行时，不输出		?
sed -n '/regexp/p'		只显示匹配正则表达式的行（模拟“grep”）
sed '/regexp/!d'		只显示匹配正则表达式的行（模拟“grep”）
sed -n '/regexp/!p'		只显示“不”匹配正则表达式的行（模拟“grep -v”）
sed '/regexp/d'			只显示“不”匹配正则表达式的行（模拟“grep -v”）
sed -n '/regexp/{g;1!p;};h'		查找“regexp”并将匹配行的上一行显示出来，但并不显示匹配行。使用h把前一行数据保存到缓冲区。
sed -n '/regexp/{n;p;}'		查找“regexp”并将匹配行的下一行显示出来，但并不显示匹配行
sed -n -e '/regexp/{=;x;1!p;g;$!N;p;D;}' -e h		显示包含“regexp”的行及其前后行，并在第一行之前加上“regexp”所在行的行号 （类似“grep -A1 -B1”）	?
sed '/AAA/!d; /BBB/!d; /CCC/!d'  显示包含“AAA”、“BBB”或“CCC”的行（任意次序）
sed '/AAA.*BBB.*CCC/!d'		显示包含“AAA”、“BBB”和“CCC”的行（固定次序）
sed -e '/AAA/b' -e '/BBB/b' -e '/CCC/b' -e d	显示包含“AAA”“BBB”或“CCC”的行 （模拟“egrep”）
 gsed '/AAA\|BBB\|CCC/!d'                        # 对GNU sed有效

 # 显示包含“AAA”的段落 （段落间以空行分隔）
 # HHsed v1.5 必须在“x;”后加入“G;”，接下来的3个脚本都是这样
 sed -e '/./{H;$!d;}' -e 'x;/AAA/!d;'

 # 显示包含“AAA”“BBB”和“CCC”三个字串的段落 （任意次序）
 sed -e '/./{H;$!d;}' -e 'x;/AAA/!d;/BBB/!d;/CCC/!d'

 # 显示包含“AAA”、“BBB”、“CCC”三者中任一字串的段落 （任意次序）
 sed -e '/./{H;$!d;}' -e 'x;/AAA/b' -e '/BBB/b' -e '/CCC/b' -e d
 gsed '/./{H;$!d;};x;/AAA\|BBB\|CCC/b;d'         # 只对GNU sed有效

 # 显示包含65个或以上字符的行
 sed -n '/^.\{65\}/p'

 # 显示包含65个以下字符的行
 sed -n '/^.\{65\}/!p'            # 方法1，与上面的脚本相对应
 sed '/^.\{65\}/d'                # 方法2，更简便一点的方法

 # 显示部分文本――从包含正则表达式的行开始到最后一行结束
 sed -n '/regexp/,$p'

 # 显示部分文本――指定行号范围（从第8至第12行，含8和12行）
 sed -n '8,12p'                   # 方法1
 sed '8,12!d'                     # 方法2

 # 显示第52行
 sed -n '52p'                     # 方法1
 sed '52!d'                       # 方法2
 sed '52q;d'                      # 方法3, 处理大文件时更有效率

 # 从第3行开始，每7行显示一次    
 gsed -n '3~7p'                   # 只对GNU sed有效
 sed -n '3,${p;n;n;n;n;n;n;}'     # 其他sed

 # 显示两个正则表达式之间的文本（包含）
 sed -n '/Iowa/,/Montana/p'       # 区分大小写方式

选择性地删除特定行：
--------

 # 显示通篇文档，除了两个正则表达式之间的内容
 sed '/Iowa/,/Montana/d'

 # 删除文件中相邻的重复行（模拟“uniq”）
 # 只保留重复行中的第一行，其他行删除
 sed '$!N; /^\(.*\)\n\1$/!P; D'

 # 删除文件中的重复行，不管有无相邻。注意hold space所能支持的缓存
 # 大小，或者使用GNU sed。
 sed -n 'G; s/\n/&&/; /^\([ -~]*\n\).*\n\1/d; s/\n//; h; P'

 # 删除除重复行外的所有行（模拟“uniq -d”）
 sed '$!N; s/^\(.*\)\n\1$/\1/; t; D'

 # 删除文件中开头的10行
 sed '1,10d'

 # 删除文件中的最后一行
 sed '$d'

 # 删除文件中的最后两行
 sed 'N;$!P;$!D;$d'

 # 删除文件中的最后10行
 sed -e :a -e '$d;N;2,10ba' -e 'P;D'   # 方法1
 sed -n -e :a -e '1,10!{P;N;D;};N;ba'  # 方法2

 # 删除8的倍数行
 gsed '0~8d'                           # 只对GNU sed有效
 sed 'n;n;n;n;n;n;n;d;'                # 其他sed

 # 删除匹配式样的行
 sed '/pattern/d'                      # 删除含pattern的行。当然pattern
                                       # 可以换成任何有效的正则表达式

 # 删除文件中的所有空行（与“grep '.' ”效果相同）
 sed '/^$/d'                           # 方法1
 sed '/./!d'                           # 方法2

 # 只保留多个相邻空行的第一行。并且删除文件顶部和尾部的空行。
 # （模拟“cat -s”）
 sed '/./,/^$/!d'        #方法1，删除文件顶部的空行，允许尾部保留一空行
 sed '/^$/N;/\n$/D'      #方法2，允许顶部保留一空行，尾部不留空行

 # 只保留多个相邻空行的前两行。
 sed '/^$/N;/\n$/N;//D'

 # 删除文件顶部的所有空行
 sed '/./,$!d'

 # 删除文件尾部的所有空行
 sed -e :a -e '/^\n*$/{$d;N;ba' -e '}'  # 对所有sed有效
 sed -e :a -e '/^\n*$/N;/\n$/ba'        # 同上，但只对 gsed 3.02.*有效

 # 删除每个段落的最后一行
 sed -n '/^$/{p;h;};/./{x;/./p;}'

特殊应用：
--------

 # 移除手册页（man page）中的nroff标记。在Unix System V或bash shell下使
 # 用'echo'命令时可能需要加上 -e 选项。
 sed "s/.`echo \\\b`//g"    # 外层的双括号是必须的（Unix环境）
 sed 's/.^H//g'             # 在bash或tcsh中, 按 Ctrl-V 再按 Ctrl-H
 sed 's/.\x08//g'           # sed 1.5，GNU sed，ssed所使用的十六进制的表示方法

 # 提取新闻组或 e-mail 的邮件头
 sed '/^$/q'                # 删除第一行空行后的所有内容

 # 提取新闻组或 e-mail 的正文部分
 sed '1,/^$/d'              # 删除第一行空行之前的所有内容

 # 从邮件头提取“Subject”（标题栏字段），并移除开头的“Subject:”字样
 sed '/^Subject: */!d; s///;q'

 # 从邮件头获得回复地址
 sed '/^Reply-To:/q; /^From:/h; /./d;g;q'

 # 获取邮件地址。在上一个脚本所产生的那一行邮件头的基础上进一步的将非电邮
 # 地址的部分剃除。（见上一脚本）
 sed 's/ *(.*)//; s/>.*//; s/.*[:<] *//'

 # 在每一行开头加上一个尖括号和空格（引用信息）
 sed 's/^/> /'

 # 将每一行开头处的尖括号和空格删除（解除引用）
 sed 's/^> //'

 # 移除大部分的HTML标签（包括跨行标签）
 sed -e :a -e 's/<[^>]*>//g;/</N;//ba'

 # 将分成多卷的uuencode文件解码。移除文件头信息，只保留uuencode编码部分。
 # 文件必须以特定顺序传给sed。下面第一种版本的脚本可以直接在命令行下输入；
 # 第二种版本则可以放入一个带执行权限的shell脚本中。（由Rahul Dhesi的一
 # 个脚本修改而来。）
 sed '/^end/,/^begin/d' file1 file2 ... fileX | uudecode   # vers. 1
 sed '/^end/,/^begin/d' "$@" | uudecode                    # vers. 2

 # 将文件中的段落以字母顺序排序。段落间以（一行或多行）空行分隔。GNU sed使用
 # 字元“\v”来表示垂直制表符，这里用它来作为换行符的占位符――当然你也可以
 # 用其他未在文件中使用的字符来代替它。
 sed '/./{H;d;};x;s/\n/={NL}=/g' file | sort | sed '1s/={NL}=//;s/={NL}=/\n/g'
 gsed '/./{H;d};x;y/\n/\v/' file | sort | sed '1s/\v//;y/\v/\n/'

 # 分别压缩每个.TXT文件，压缩后删除原来的文件并将压缩后的.ZIP文件
 # 命名为与原来相同的名字（只是扩展名不同）。（DOS环境：“dir /b”
 # 显示不带路径的文件名）。
 echo @echo off >zipup.bat
 dir /b *.txt | sed "s/^\(.*\)\.TXT/pkzip -mo \1 \1.TXT/" >>zipup.bat


使用SED：Sed接受一个或多个编辑命令，并且每读入一行后就依次应用这些命令。
当读入第一行输入后，sed对其应用所有的命令，然后将结果输出。接着再读入第二
行输入，对其应用所有的命令……并重复这个过程。上一个例子中sed由标准输入设
备（即命令解释器，通常是以管道输入的形式）获得输入。在命令行给出一个或多
个文件名作为参数时，这些文件取代标准输入设备成为sed的输入。sed的输出将被
送到标准输出（显示器）。因此：

 cat filename | sed '10q'         # 使用管道输入
 sed '10q' filename               # 同样效果，但不使用管道输入
 sed '10q' filename > newfile     # 将输出转移（重定向）到磁盘上

要了解sed命令的使用说明，包括如何通过脚本文件（而非从命令行）来使用这些命
令，请参阅《sed & awk》第二版，作者Dale Dougherty和Arnold Robbins
（O'Reilly，1997；http://www.ora.com），《UNIX Text Processing》，作者
Dale Dougherty和Tim O'Reilly（Hayden Books，1987）或者是Mike Arst写的教
程――压缩包的名称是“U-SEDIT2.ZIP”（在许多站点上都找得到）。要发掘sed
的潜力，则必须对“正则表达式”有足够的理解。正则表达式的资料可以看
《Mastering Regular Expressions》作者Jeffrey Friedl（O'reilly 1997）。
Unix系统所提供的手册页（“man”）也会有所帮助（试一下这些命令
“man sed”、“man regexp”，或者看“man ed”中关于正则表达式的部分），但
手册提供的信息比较“抽象”――这也是它一直为人所诟病的。不过，它本来就不
是用来教初学者如何使用sed或正则表达式的教材，而只是为那些熟悉这些工具的人
提供的一些文本参考。

括号语法：前面的例子对sed命令基本上都使用单引号（'...'）而非双引号
（"..."）这是因为sed通常是在Unix平台上使用。单引号下，Unix的shell（命令
解释器）不会对美元符（$）和后引号（`...`）进行解释和执行。而在双引号下
美元符会被展开为变量或参数的值，后引号中的命令被执行并以输出的结果代替
后引号中的内容。而在“csh”及其衍生的shell中使用感叹号（!）时需要在其前
面加上转义用的反斜杠（就像这样：\!）以保证上面所使用的例子能正常运行
（包括使用单引号的情况下）。DOS版本的Sed则一律使用双引号（"..."）而不是
引号来圈起命令。

'\t'的用法：为了使本文保持行文简洁，我们在脚本中使用'\t'来表示一个制表
符。但是现在大部分版本的sed还不能识别'\t'的简写方式，因此当在命令行中为
脚本输入制表符时，你应该直接按TAB键来输入制表符而不是输入'\t'。下列的工
具软件都支持'\t'做为一个正则表达式的字元来表示制表符：awk、perl、HHsed、
sedmod以及GNU sed v3.02.80。

不同版本的SED：不同的版本间的sed会有些不同之处，可以想象它们之间在语法上
会有差异。具体而言，它们中大部分不支持在编辑命令中间使用标签（:name）或分
支命令（b,t），除非是放在那些的末尾。这篇文档中我们尽量选用了可移植性较高
的语法，以使大多数版本的sed的用户都能使用这些脚本。不过GNU版本的sed允许使
用更简洁的语法。想像一下当读者看到一个很长的命令时的心情：

   sed -e '/AAA/b' -e '/BBB/b' -e '/CCC/b' -e d

好消息是GNU sed能让命令更紧凑：

   sed '/AAA/b;/BBB/b;/CCC/b;d'      # 甚至可以写成
   sed '/AAA\|BBB\|CCC/b;d'

此外，请注意虽然许多版本的sed接受象“/one/ s/RE1/RE2/”这种在's'前带有空
格的命令，但这些版本中有些却不接受这样的命令:“/one/! s/RE1/RE2/”。这时
只需要把中间的空格去掉就行了。

速度优化：当由于某种原因（比如输入文件较大、处理器或硬盘较慢等）需要提高
命令执行速度时，可以考虑在替换命令（“s/.../.../”）前面加上地址表达式来
提高速度。举例来说：

   sed 's/foo/bar/g' filename         # 标准替换命令
   sed '/foo/ s/foo/bar/g' filename   # 速度更快
   sed '/foo/ s//bar/g' filename      # 简写形式

当只需要显示文件的前面的部分或需要删除后面的内容时，可以在脚本中使用“q”
命令（退出命令）。在处理大的文件时，这会节省大量时间。因此：

   sed -n '45,50p' filename           # 显示第45到50行
   sed -n '51q;45,50p' filename       # 一样，但快得多

如果你有其他的单行脚本想与大家分享或者你发现了本文档中错误的地方，请发电
子邮件给本文档的作者（Eric Pement）。邮件中请记得提供你所使用的sed版本、 
该sed所运行的操作系统及对问题的适当描述。本文所指的单行脚本指命令行的长
度在65个字符或65个以下的sed脚本〔译注1〕。本文档的各种脚本是由以下所列作
者所写或提供：

 Al Aab                               # 建立了“seders”邮件列表
 Edgar Allen                          # 许多方面
 Yiorgos Adamopoulos                  # 许多方面
 Dale Dougherty                       # 《sed & awk》作者
 Carlos Duarte                        # 《do it with sed》作者
 Eric Pement                          # 本文档的作者
 Ken Pizzini                          # GNU sed v3.02 的作者
 S.G. Ravenhall                       # 去html标签脚本
 Greg Ubben                           # 有诸多贡献并提供了许多帮助
----------------------------------------------------------------------------------------------------